#include "Packages/com.unity.render-pipelines.high-definition/Runtime/PostProcessing/Shaders/MotionBlurCommon.hlsl"

#pragma kernel MotionBlurCS
//#pragma enable_d3d11_debug_symbols

RWTexture2D<float3> _OutputTexture;
Texture2D _InputTexture;

#define SOFT_Z_EXTENT 0.01


// Known Bugs TODO_FCC:
//	- When background is moving in directions very different than foreground (REPRO: set FPS to 30, put camera low, move it forward with dancing guys in scene. Notice artifacts when dancer crosses the horizon.)
//	- When max velocity is above the tile size, in the rotating+moving camera case with a more noisy background, if you pause, you can see the tiles... yuck. Pretty much the same issue here. 

// Various TODOs TODO_FCC:
//	- Apply intensity scale to camera rotation component as well.

// ---------------------------------------------
// Debug
// ---------------------------------------------

// ------------Debug Visualization------------------
#define NO_DEBUG 0
#define TILE_VIS 1
#define WEIGHT_VIS 2
#define MAX_VELOCITY 3
#define CUSTOM 4
#define SAMPLE_COUNT 5

#define DEBUG_VIEW NO_DEBUG


// ------------Debug Weight------------------
#define NO_DEBUG 0
#define CONSTANT 1
#define ONLY_SPREAD 2
#define ONLY_DEPTH_COMPARE 3
#define CUSTOM 4

#define DEBUG_WEIGHT NO_DEBUG

// ------------Debug Execution ------------------
#define NORMAL 0
#define ONLY_SLOW_PATH 1
#define ONLY_FAST_PATH 2

#define DEBUG_EXECUTION NORMAL

// ------------Debug Slow Path ------------------
#define NO_DEBUG 0
#define DEBUG_ONLY_FORWARD 1
#define DEBUG_ONLY_BACKWARD 2

#define DEBUG_SLOW_PATH NO_DEBUG

// ------------Options------------------
#define MIRROR_WEIGHTS 1        // TODO_FCC: To test with noisy background.
#define TILE_JITTER 1
#define GUERTIN2014_DOUBLE_DIR 1
#define OPTIMIZE_SAMPLE_COUNT 1

// ---------------------------------------------
// Misc utils
// ---------------------------------------------
#define INTERLEAVED_GRADIENT_NOISE 0
#define CHECKERBOARD 1
#define DITHER_SCHEME INTERLEAVED_GRADIENT_NOISE

float RandomValue(uint2 pixCoord, uint frameCount)
{
#if DITHER_SCHEME == INTERLEAVED_GRADIENT_NOISE
    return InterleavedGradientNoise(pixCoord.xy, 0);
#elif DITHER_SCHEME == CHECKERBOARD
    float scale = 0.25f;
    float2 posMod = float2 (pixCoord & 1);
    return (-scale + 2.0f * scale * posMod.x) * (-1.0f + 2.0f * posMod.y);
#endif
    return 0.0f;
}


// TODO_FCC: Get better jitter. 
float2 GetTileUV(uint2 pixCoord, float2 randomVals)
{
    randomVals -= 0.5f;
    randomVals *= 0.5f;


#if !TILE_JITTER
    randomVals = 0;
#endif
    return ((pixCoord / TILE_SIZE) + randomVals) * _TileTargetSize.zw;
}


// ---------------------------------------------
// Weight functions
// ---------------------------------------------

#define DEBUG_USE_SOUZA_DEPTH 0

// Return foreground and background weights
float2 DepthCompare_Souza(float centralDepth, float sampleDepth, float depthScale)
{
	float2 z0 = float2(centralDepth, sampleDepth);
	float2 z1 = float2(sampleDepth, centralDepth);

	return saturate(0.5f + (z0 * depthScale) - (z1 * depthScale));

	return saturate(0.5f + float2(depthScale, -depthScale) * (sampleDepth - centralDepth));
}

// Return foreground and background weights
float2 DepthCompare(float centralDepth, float sampleDepth, float depthScale)
{
#if DEBUG_USE_SOUZA_DEPTH
	return DepthCompare_Souza(centralDepth, sampleDepth, depthScale);
#endif
    return saturate(0.5f + float2(depthScale, -depthScale) * (sampleDepth - centralDepth));
}


// Spread compare function
float2 SpreadCompare(float offsetLength, float2 spreadLength, float pixelToSampleScale)
{
    return saturate(pixelToSampleScale * spreadLength - max(offsetLength - 1.0f, 0.0f));
}

float SampleWeight(float centralDepth, float sampleDepth, float offsetLength, float centralSpreadLength, float sampleSpreadLength, float pixelToSampleScale, float depthScale)
{
    float2 depthWeights = DepthCompare(centralDepth, sampleDepth, depthScale);
    float2 spread = SpreadCompare(offsetLength, float2(centralSpreadLength, sampleSpreadLength), pixelToSampleScale);
#if DEBUG_WEIGHT == CONSTANT
    return 1;
#elif DEBUG_WEIGHT == ONLY_SPREAD
    return spread;
#elif DEBUG_WEIGHT == ONLY_DEPTH_COMPARE
    return depthWeights.y ;
#elif DEBUG_WEIGHT == CUSTOM
    depthWeights = DepthCompare(centralDepth, sampleDepth, depthScale);
    spread = SpreadCompare(offsetLength, float2(centralSpreadLength, sampleSpreadLength), pixelToSampleScale);
    return depthWeights.x;
#else
    return dot(depthWeights, spread);
#endif
}

void MirrorWeights(float depth1, float depth2, float vel1, float vel2, inout float weight1, inout float weight2)
{
    bool2 mirror = bool2( depth1 > depth2, vel1 > vel2 );
    weight1 = all( mirror ) ? weight2 : weight1;
    weight2 = any( mirror ) ? weight2 : weight1;
}

// ---------------------------------------------
// Sample processing 
// ---------------------------------------------

float3 ProcessSampleFastPath(uint sampleNumber, float2 dir, float invSampleCount, float2 centralUV, float randomVal, float dirSign)
{
    float2 currDir = dirSign * dir;

    float  offsetLength = (sampleNumber + 0.5f) + (dirSign * (randomVal - 0.5));
    float2 sampleUV = centralUV + (offsetLength*invSampleCount) * currDir;

    float3 sampleColor    = SAMPLE_TEXTURE2D_LOD(_InputTexture, s_point_clamp_sampler, sampleUV, 0).xyz;

    return sampleColor;
}

float4 ProcessSample(uint sampleNumber, float2 dir, float invSampleCount, float2 centralUV, float centralDepth, float centralVelocityLen, float pixelToSampleScale, float randomVal, float dirSign, out float outDepth, out float outVelLength)
{
    float2 currDir = dirSign * dir;

    float  offsetLength = (sampleNumber + 0.5f) + (dirSign * (randomVal - 0.5));
    float2 sampleUV = centralUV + (offsetLength*invSampleCount) * currDir;

    float3 sampleVelDepth = SAMPLE_TEXTURE2D_LOD(_VelocityAndDepth, s_point_clamp_sampler, sampleUV, 0).xyz;
    float3 sampleColor    = SAMPLE_TEXTURE2D_LOD(_InputTexture, s_point_clamp_sampler, sampleUV, 0).xyz;

    outVelLength = VelocityLengthInPixelsFromEncoded(sampleVelDepth.xy);
    outDepth = sampleVelDepth.z;

    float  sampleWeight = SampleWeight(centralDepth, outDepth, offsetLength, centralVelocityLen, outVelLength, pixelToSampleScale, SOFT_Z_EXTENT);

    return float4(sampleColor, sampleWeight);
}


// ---------------------------------------------
// Kernel
// ---------------------------------------------

[numthreads(8,8,1)]
void MotionBlurCS(uint3 dispatchThreadId : SV_DispatchThreadID)
{

    float3 debugColor = 1.0f;

    // Get central sample early.
    float3 centralColor = _InputTexture[dispatchThreadId.xy].xyz;

	float2 randomVals = float2(RandomValue(dispatchThreadId.xy, 0), RandomValue(dispatchThreadId.xy, 1));

    float2 tileUV = GetTileUV(dispatchThreadId.xy, randomVals);
    float3 tileMaxNeighbourhood = SAMPLE_TEXTURE2D_LOD(_TileMaxNeighbourhood, s_point_clamp_sampler, tileUV, 0.0f).xyz;

    // Get velocity in pixels extents.
    float2 maxVel = DecodeVelocityFromPacked(tileMaxNeighbourhood.xy);
    float maxVelLength = VelocityLengthInPixelsFromEncoded(tileMaxNeighbourhood.xy);
    float minVelLengthInPixels =  tileMaxNeighbourhood.z * _ScreenMagnitude;

    bool earlyOut = maxVelLength <= _MinVelThreshold;

#if defined(SUPPORTS_WAVE_INTRINSICS)
    earlyOut = WaveActiveAllTrue(earlyOut);
    bool fastPath = WaveActiveAllTrue(minVelLengthInPixels > (_MinMaxVelRatioForSlowPath * maxVelLength));
#else
    // TODO: force it scalar with interlocked add or something like that (it is not always due to the jittering)
    bool fastPath = minVelLengthInPixels > (_MinMaxVelRatioForSlowPath * maxVelLength);
#endif

#if DEBUG_EXECUTION == ONLY_SLOW_PATH
    earlyOut = false;
    fastPath = false;
#elif DEBUG_EXECUTION == ONLY_FAST_PATH
    earlyOut = false;
    fastPath = true;
#endif

#if DEBUG_VIEW == TILE_VIS
    if (earlyOut)
    {
        debugColor = float3(0, 1, 0);
    }
    else if (fastPath)
    {
        debugColor = float3(1, 1, 0);
    }
    else
    {
        debugColor = float3(1, 0, 0);
    }

    _OutputTexture[dispatchThreadId.xy] = 0.25f * centralColor + 0.75f * debugColor.xyz;

#else

    float3 outVal = 1;
    if (earlyOut)
    {
        _OutputTexture[dispatchThreadId.xy] = centralColor;
    }
    else
    {
#if OPTIMIZE_SAMPLE_COUNT
		uint actualSampleCount = min(uint(maxVelLength) + (uint(maxVelLength) & 1), uint(_SampleCount));
		actualSampleCount = max(actualSampleCount, 2);
#else 
		uint actualSampleCount = _SampleCount;
#endif
        const float invSampleCount = 1.0f / actualSampleCount;
		uint stepCount = actualSampleCount / 2u;


        float2 centerSampleUV = (0.5f + dispatchThreadId.xy) * _ScreenSize.zw;

		float randomVal = randomVals.x;
        float2 dir = 0.5f * maxVel;

        float3 colorAccumulation = 0.0f;

        if (fastPath)
        {
            for (uint i = 0; i < stepCount; ++i)
            {
                colorAccumulation += ProcessSampleFastPath(i, dir, invSampleCount, centerSampleUV, randomVal, -1);
                colorAccumulation += ProcessSampleFastPath(i, dir, invSampleCount, centerSampleUV, randomVal, 1);
            }

            colorAccumulation *= invSampleCount;
#if DEBUG_VIEW == WEIGHT_VIS
            colorAccumulation = 0;
#endif
        }
        else
        {
            // Slow path.
            float3 velocityAndDepth = SAMPLE_TEXTURE2D_LOD(_VelocityAndDepth, s_point_clamp_sampler, centerSampleUV, 0).xyz;

            float pixelToSampleScale = _SampleCount * 0.5f * maxVelLength;
            float2 centralTapVelocity = DecodeVelocityFromPacked(velocityAndDepth.xy);
            float  centralVelocityLen = VelocityLengthInPixelsFromEncoded(velocityAndDepth.xy);
#if GUERTIN2014_DOUBLE_DIR
            float2 centralDir = centralVelocityLen < 1 ? dir : centralTapVelocity * 0.5f;
#endif

            float  centralDepth = velocityAndDepth.z;

            float4 accumulation = 0.0f;
            for (uint i = 0; i < stepCount; ++i)
            {
#if GUERTIN2014_DOUBLE_DIR
                dir = i % 2u == 0 ? centralDir : dir;
#endif
				// TODO_FCC: When done with debug, no need to initialize the following.
				float fw_Depth = 0;
				float bw_Depth = 0;
				float fw_VelLength = 0;
				float bw_VelLength = 0;
				float4 fw_Sample = 0;
				float4 bw_Sample = 0;
#if DEBUG_SLOW_PATH != DEBUG_ONLY_BACKWARD
                 fw_Sample = ProcessSample(i, dir, invSampleCount, centerSampleUV, centralDepth, centralVelocityLen, pixelToSampleScale, randomVal, -1, fw_Depth, fw_VelLength);
#endif
#if DEBUG_SLOW_PATH != DEBUG_ONLY_FORWARD
                 bw_Sample = ProcessSample(i, dir, invSampleCount, centerSampleUV, centralDepth, centralVelocityLen, pixelToSampleScale, randomVal, 1, bw_Depth, bw_VelLength);
#endif
                // Mirror weights
#if MIRROR_WEIGHTS
                MirrorWeights(fw_Depth, bw_Depth, fw_VelLength, bw_VelLength, fw_Sample.w, bw_Sample.w);
#endif
                accumulation += float4(fw_Sample.w * fw_Sample.rgb, fw_Sample.w) + float4(bw_Sample.w * bw_Sample.rgb, bw_Sample.w);
            }
            accumulation *= invSampleCount;
#if DEBUG_SLOW_PATH != NO_DEBUG 
			accumulation *= 2.0f;
#endif

            colorAccumulation = accumulation.rgb + (1.0f - accumulation.w) * centralColor;

#if DEBUG_VIEW == WEIGHT_VIS
            colorAccumulation = accumulation.rgb;
			colorAccumulation.b = accumulation.w;
#endif

#if DEBUG_VIEW == WEIGHT_VIS
#endif
        }


#if DEBUG_VIEW == MAX_VELOCITY
        colorAccumulation = float3(maxVel, 0.0f);
        float maxVelLenPix = VelocityLengthInPixelsFromEncoded(tileMaxNeighbourhood.xy);
        colorAccumulation = maxVelLenPix;
#endif

#if DEBUG_VIEW == SAMPLE_COUNT
		colorAccumulation = colorAccumulation * 0.25f + 0.75f * lerp(float3(0.0f, 1.0f, 0.0f), float3(1.0, 0.0, 0.0), actualSampleCount / _SampleCount);
#endif


        _OutputTexture[dispatchThreadId.xy] = colorAccumulation;
    }


#endif
}
